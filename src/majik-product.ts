import {
  deserializeMoney,
  MajikMoney,
  serializeMoney,
} from "@thezelijah/majik-money";
import {
  COGSItem,
  ISODateString,
  MonthlyCapacity,
  ObjectType,
  ProductID,
  ProductMetadata,
  ProductSettings,
  StartDateInput,
  YYYYMM,
} from "./types";
import {
  CapacityPeriodResizeMode,
  ProductStatus,
  ProductType,
  ProductVisibility,
} from "./enums";
import {
  autogenerateID,
  createEmptyProductFinance,
  generateSlug,
  isValidYYYYMM,
  monthsInPeriod,
  offsetMonthsToYYYYMM,
  normalizeStartDate,
} from "./utils";

/**
 * Represents a product in the Majik system with metadata, finance, COGS, and supply management.
 * Provides utilities for calculating revenue, COGS, profit, margins, and aggregate statistics.
 */
export class MajikProduct {
  readonly __type = "MajikProduct";
  readonly __object: ObjectType = "class";
  id: ProductID;
  slug: string;
  name: string;
  category: string;
  srp: MajikMoney;
  status: ProductStatus;
  type: ProductType;
  timestamp: ISODateString;
  last_update: ISODateString;

  metadata: ProductMetadata;
  settings: ProductSettings;
  private financeDirty = true;

  /**
   * Creates a new MajikProduct instance.
   * @param id - Optional. Product ID. Will be autogenerated if not provided.
   * @param slug - Optional. Product slug. Will be generated from the name if not provided.
   * @param name - Product name.
   * @param metadata - Product metadata including COGS, supply plan, finance, and description.
   * @param settings - Product settings including status and visibility.
   * @param timestamp - Optional. Creation timestamp in ISO format.
   * @param last_update - Optional. Last updated timestamp in ISO format.
   */
  constructor(
    id: ProductID | undefined,
    slug: string | undefined,
    name: string,
    metadata: ProductMetadata,
    settings: ProductSettings,
    timestamp: ISODateString = new Date().toISOString(),
    last_update: ISODateString = new Date().toISOString()
  ) {
    this.id = id || autogenerateID("mjkp");
    this.slug = slug || generateSlug(name);
    this.name = name;
    this.metadata = metadata;
    this.settings = settings ?? {
      status: ProductStatus.ACTIVE,
      visibility: ProductVisibility.PRIVATE,
      system: { isRestricted: false },
    };

    this.type = this.metadata.type;
    this.category = this.metadata.category;
    this.srp = this.metadata.srp;
    this.status = this.settings.status;

    this.timestamp = timestamp;
    this.last_update = last_update;
  }

  private markFinanceDirty(): void {
    this.financeDirty = true;
  }

  /**
   * Returns a MajikMoney instance representing zero in the product currency.
   * @param currencyCode - Optional currency code. Defaults to the product's SRP currency or PHP.
   * @returns {MajikMoney} Zero money object.
   */
  private DEFAULT_ZERO(currencyCode?: string): MajikMoney {
    const code = currencyCode || this.srp?.currency?.code || "PHP";
    return MajikMoney.fromMinor(0, code);
  }

  /**
   * Initializes and creates a new `MajikProduct` with default and null values.
   * @param type - The type of product to initialize. Defaults to `PHYSICAL`. Use Enum `ProductType`.
   * @returns A new `MajikProduct` instance.
   */
  static initialize(
    name: string,
    type: ProductType = ProductType.PHYSICAL,
    srp: MajikMoney,
    stock: number = 1,
    category: string = "Other",
    descriptionText?: string,
    skuID?: string
  ): MajikProduct {
    if (!name || typeof name !== "string" || name.trim() === "") {
      throw new Error("Name must be a valid non-empty string.");
    }

    if (!category || typeof category !== "string" || category.trim() === "") {
      throw new Error("Category must be a valid non-empty string.");
    }

    // Set default values for optional parameters
    const defaultMetadata: ProductMetadata = {
      description: {
        text: descriptionText || "A new product.",
      },
      type: type,
      category: category,
      srp: srp,
      inventory: {
        stock: stock,
      },
      sku: skuID || undefined,
      cogs: [],
      finance: createEmptyProductFinance(srp.currency.code),
    };

    const defaultSettings: ProductSettings = {
      visibility: ProductVisibility.PRIVATE,
      status: ProductStatus.ACTIVE,
      system: {
        isRestricted: false,
      },
    };

    return new MajikProduct(
      undefined,
      undefined,
      name || "My Product",
      defaultMetadata,
      defaultSettings,
      undefined,
      undefined
    );
  }

  /* ------------------ METADATA HELPERS ------------------ */

  /**
   * Updates the product name and slug.
   * @param name - New product name.
   * @returns {this} Updated product instance.
   */
  setName(name: string): this {
    if (!name || typeof name !== "string" || name.trim() === "") {
      throw new Error("Name must be a valid non-empty string.");
    }

    this.name = name;
    this.slug = generateSlug(name);
    this.updateTimestamp();
    return this;
  }

  /**
   * Updates the product SRP (suggested retail price).
   * @param srp - New SRP as MajikMoney.
   * @returns {this} Updated product instance.
   */
  setSRP(srp: MajikMoney): this {
    this.srp = srp;
    this.metadata.srp = srp;
    this.updateTimestamp();
    this.markFinanceDirty();
    return this;
  }

  /**
   * Updates the product category.
   * @param category - New category string.
   * @returns {this} Updated product instance.
   */
  setCategory(category: string): this {
    if (!category || typeof category !== "string" || category.trim() === "") {
      throw new Error("Category must be a valid non-empty string.");
    }

    this.category = category;
    this.metadata.category = category;
    this.updateTimestamp();
    return this;
  }

  /**
   * Updates the HTML and plain text of the Product Description.
   * @param html - The new html of the Description. Must be a non-empty string.
   * @param text - The new plain text of the Description. Must be a non-empty string.
   * @throws Will throw an error if either the `html` or `text` are not provided or are not a string.
   */
  setDescription(html: string, text: string): this {
    if (!html || typeof html !== "string" || html.trim() === "") {
      throw new Error("HTML must be a valid non-empty string.");
    }

    if (!text || typeof text !== "string" || text.trim() === "") {
      throw new Error("Text must be a valid non-empty string.");
    }

    this.metadata.description.html = html;
    this.metadata.description.text = text;
    this.updateTimestamp();
    return this;
  }

  /**
   * Updates the Plain Text of the Product Description.
   * @param text - The new Description Text of the Product. Must be a non-empty string.
   * @throws Will throw an error if the `text` is not provided or is not a string.
   */
  setDescriptionText(text: string): this {
    if (!text || typeof text !== "string" || text.trim() === "") {
      throw new Error("Description Text must be a valid non-empty string.");
    }

    this.metadata.description.text = text;
    this.updateTimestamp();
    return this;
  }

  /**
   * Updates the Description of the Product.
   * @param html - The new Description of the Product. Must be a non-empty string.
   * @throws Will throw an error if the `html` is not provided or is not a string.
   */
  setDescriptionHTML(html: string): this {
    if (!html || typeof html !== "string" || html.trim() === "") {
      throw new Error("Description HTML must be a valid non-empty string.");
    }

    this.metadata.description.html = html;
    this.updateTimestamp();
    return this;
  }

  /**
   * Updates the SEO of the Product Description.
   * @param text - The new SEO Text of the Product. Must be a non-empty string.
   * @throws Will throw an error if the `text` is not provided or is not a string.
   */
  setDescriptionSEO(text: string): this {
    if (!text || typeof text !== "string" || text.trim() === "") {
      this.metadata.description.seo = undefined;
      this.updateTimestamp();
      return this;
    }

    this.metadata.description.seo = text;
    this.updateTimestamp();
    return this;
  }

  /**
   * Updates the Type of the Product.
   * @param type - The new Type of the Product. Use Enum `ProductType`.
   * @throws Will throw an error if the `type` is not provided or is not a string.
   */
  setType(type: ProductType): this {
    if (!Object.values(ProductType).includes(type)) {
      throw new Error("Invalid Product type.");
    }

    this.metadata.type = type;
    this.type = type;
    this.updateTimestamp();
    return this;
  }

  /**
   * Returns the SEO text for this product if available; otherwise the content plain text;
   */
  get seo(): string {
    if (!!this.metadata.description.seo?.trim())
      return this.metadata.description.seo;
    return this.metadata.description.text;
  }

  /**
   * Updates the product stock count.
   * @param amount - New stock/inventory count amount.
   * @returns {this} Updated product instance.
   */
  setStock(amount: number): this {
    if (!amount || amount <= 0) {
      this.metadata.inventory.stock = null;
      return this;
    }

    this.metadata.inventory.stock = amount;
    this.updateTimestamp();
    return this;
  }

  /* ------------------ COGS MANAGEMENT ------------------ */

  /**
   * Returns true if the product has at least one COGS (cost breakdown) item.
   */
  hasCostBreakdown(): boolean {
    return Array.isArray(this.metadata.cogs) && this.metadata.cogs.length > 0;
  }

  /**
   * Creates and adds a new COGS item using primitive inputs.
   * This method automatically computes subtotal and generates an ID.
   *
   * @param name - Cost item name (e.g. "Packaging", "Raw Material")
   * @param unitCost - Cost per unit
   * @param quantity - Quantity per product unit (default: 1)
   * @param unit - Optional unit label (e.g. "kg", "pcs")
   * @returns {this} Updated product instance
   */
  addCOGS(
    name: string,
    unitCost: MajikMoney,
    quantity: number = 1,
    unit?: string
  ): this {
    if (!name.trim()) throw new Error("COGS name cannot be empty");
    if (quantity <= 0)
      throw new Error("COGS quantity must be greater than zero");

    // Optional: enforce same currency as SRP
    this.assertCurrency(unitCost);

    const newItem: COGSItem = {
      id: autogenerateID("mjkpcost"),
      item: name,
      quantity,
      unitCost,
      unit,
      subtotal: unitCost.multiply(quantity),
    };

    this.metadata.cogs.push(newItem);
    this.updateTimestamp();
    this.markFinanceDirty();
    return this;
  }

  /**
   * Pushes a fully constructed COGS item into the product.
   * Use this when loading from DB or importing external data.
   *
   * @param item - Fully-formed COGSItem
   * @returns {this} Updated product instance
   */
  pushCOGS(item: COGSItem): this {
    if (!item.id) throw new Error("COGS item must have an id");
    if (!item.item?.trim()) throw new Error("COGS item must have a name");
    if (item.quantity <= 0)
      throw new Error("COGS quantity must be greater than zero");

    this.assertCurrency(item.unitCost);

    // Optional safety check
    const expectedSubtotal = item.unitCost.multiply(item.quantity);
    if (!item.subtotal.equals(expectedSubtotal)) {
      item.subtotal = expectedSubtotal;
    }

    this.metadata.cogs.push(item);
    this.updateTimestamp();
    this.markFinanceDirty();
    return this;
  }

  updateCOGS(
    id: string,
    updates: Partial<Pick<COGSItem, "quantity" | "unitCost" | "unit" | "item">>
  ): this {
    const item = this.metadata.cogs.find((c) => c.id === id);
    if (!item) throw new Error(`COGS item ${id} not found`);

    if (updates.quantity !== undefined) {
      if (updates.quantity <= 0) throw new Error("Quantity must be positive");
      item.quantity = updates.quantity;
    }

    if (updates.unitCost) {
      this.assertCurrency(updates.unitCost);
      item.unitCost = updates.unitCost;
    }

    if (!!updates?.item?.trim()) {
      item.item = updates.item;
    }

    item.unit = updates.unit ?? item.unit;
    item.subtotal = item.unitCost.multiply(item.quantity);

    this.updateTimestamp();
    this.markFinanceDirty();
    return this;
  }

  /**
   * Replaces the entire COGS array.
   * @param items - Array of COGSItem objects.
   * @returns {this} Updated product instance.
   */
  setCOGS(items: COGSItem[]): this {
    if (!Array.isArray(items)) throw new Error("COGS must be an array");
    items.forEach((item) => {
      if (
        !item.id ||
        !item.item ||
        !item.unitCost ||
        item.quantity == null ||
        !item.subtotal
      ) {
        throw new Error(
          "Each COGSItem must have id, item, unitCost, quantity, and subtotal"
        );
      }
      this.assertCurrency(item.unitCost);
    });
    this.metadata.cogs = [...items];
    this.updateTimestamp();
    this.markFinanceDirty();
    return this;
  }

  /**
   * Removes a COGS item by ID.
   * @param id - ID of the item to remove.
   * @returns {this} Updated product instance.
   */
  removeCOGS(id: string): this {
    const index = this.metadata.cogs.findIndex((c) => c.id === id);
    if (index === -1) throw new Error(`COGS item with id ${id} not found`);
    this.metadata.cogs.splice(index, 1);
    this.updateTimestamp();
    this.markFinanceDirty();
    return this;
  }

  /**
   * Clears all COGS items.
   * @returns {this} Updated product instance.
   */
  clearCostBreakdown(): this {
    this.metadata.cogs.length = 0;
    this.updateTimestamp();
    this.markFinanceDirty();
    return this;
  }

  /* ------------------ SUPPLY MANAGEMENT ------------------ */

  /**
   * Returns true if the product has at least one Capacity Plan item.
   */
  hasCapacity(): boolean {
    return (
      Array.isArray(this.metadata.supplyPlan) &&
      this.metadata.supplyPlan.length > 0
    );
  }

  /**
   * Returns the earliest (initial) YYYYMM from the supply plan.
   */
  get earliestCapacityMonth(): YYYYMM | null {
    if (!this.hasCapacity()) return null;

    const supply = this.metadata.supplyPlan!;

    return supply.reduce(
      (earliest, current) =>
        current.month < earliest ? current.month : earliest,
      supply[0].month
    );
  }

  /**
   * Returns the most recent (latest) YYYYMM from the supply plan.
   */
  get latestCapacityMonth(): YYYYMM | null {
    if (!this.hasCapacity()) return null;

    const supply = this.metadata.supplyPlan!;

    return supply.reduce(
      (latest, current) => (current.month > latest ? current.month : latest),
      supply[0].month
    );
  }

  get capacity(): MonthlyCapacity[] {
    return this.metadata?.supplyPlan || [];
  }

  /**
   * Returns the total supply units across all months.
   */
  get totalCapacity(): number {
    const supply = this.metadata.supplyPlan ?? [];
    return supply.reduce((sum, s) => sum + s.capacity + (s.adjustment ?? 0), 0);
  }

  /**
   * Returns the average supply per month.
   * Includes adjustments.
   */
  get averageMonthlyCapacity(): number {
    const supply = this.metadata.supplyPlan ?? [];
    if (supply.length === 0) return 0;

    return this.totalCapacity / supply.length;
  }

  /**
   * Returns the MonthlyCapacity entry with the highest supply.
   * Includes adjustments.
   */
  get maxSupplyMonth(): MonthlyCapacity | null {
    const supply = this.metadata.supplyPlan ?? [];
    if (supply.length === 0) return null;

    return supply.reduce((max, current) => {
      const maxUnits = max.capacity + (max.adjustment ?? 0);
      const currUnits = current.capacity + (current.adjustment ?? 0);
      return currUnits > maxUnits ? current : max;
    });
  }

  /**
   * Returns the MonthlyCapacity entry with the lowest supply.
   * Includes adjustments.
   */
  get minSupplyMonth(): MonthlyCapacity | null {
    const supply = this.metadata.supplyPlan ?? [];
    if (supply.length === 0) return null;

    return supply.reduce((min, current) => {
      const minUnits = min.capacity + (min.adjustment ?? 0);
      const currUnits = current.capacity + (current.adjustment ?? 0);
      return currUnits < minUnits ? current : min;
    });
  }

  /**
   * Generates and replaces the supply plan automatically.
   *
   * @param months - Number of months to generate from the start date.
   * @param amount - Base units for the first month.
   * @param growthRate - Optional growth rate per month (e.g. 0.03 = +3%).
   * @param startDate - Date | ISO date | YYYYMM. Defaults to current month.
   * @returns {this} Updated product instance.
   */
  generateCapacityPlan(
    months: number,
    amount: number,
    growthRate: number = 0,
    startDate?: StartDateInput
  ): this {
    if (!Number.isInteger(months) || months <= 0) {
      throw new Error("Months must be a positive integer");
    }

    if (!Number.isFinite(amount) || amount < 0) {
      throw new Error("Amount must be a non-negative number");
    }

    if (growthRate < 0) {
      throw new Error("Growth rate cannot be negative");
    }

    const start = normalizeStartDate(startDate);
    const supplyPlan: MonthlyCapacity[] = [];

    let currentUnits = amount;

    for (let i = 0; i < months; i++) {
      const date = new Date(start.getFullYear(), start.getMonth() + i, 1);

      const yyyy = date.getFullYear();
      const mm = String(date.getMonth() + 1).padStart(2, "0");
      const month = `${yyyy}-${mm}` as YYYYMM;

      supplyPlan.push({
        month,
        capacity: Math.round(currentUnits),
      });

      if (growthRate > 0) {
        currentUnits *= 1 + growthRate;
      }
    }

    return this.setCapacity(supplyPlan);
  }

  /**
   * Normalizes all supply plan entries to have the same unit amount.
   *
   * - Throws if supply plan is empty
   * - If only one entry exists, does nothing
   * - If multiple entries exist, sets all units to the provided amount
   *
   * @param amount - Unit amount to apply to all months
   * @returns {this} Updated product instance
   */
  normalizeCapacityUnits(amount: number): this {
    if (!Number.isFinite(amount) || amount < 0) {
      throw new Error("Amount must be a non-negative number");
    }

    const supply = this.metadata.supplyPlan;

    if (!supply || supply.length === 0) {
      throw new Error("Supply plan is empty");
    }

    if (supply.length === 1) {
      return this;
    }

    supply.forEach((s) => {
      s.capacity = amount;
    });

    this.updateTimestamp();
    this.markFinanceDirty();

    return this;
  }

  recomputeCapacityPeriod(
    start: YYYYMM,
    end: YYYYMM,
    mode: CapacityPeriodResizeMode = CapacityPeriodResizeMode.DEFAULT
  ): this {
    if (!isValidYYYYMM(start) || !isValidYYYYMM(end)) {
      throw new Error("Invalid YYYYMM period");
    }

    if (!this.hasCapacity()) {
      throw new Error("No existing capacity plan to recompute");
    }

    if (start > end) {
      throw new Error("Start month must be <= end month");
    }

    const newLength = monthsInPeriod(start, end);
    const oldPlan = [...this.metadata.supplyPlan!];
    const oldLength = oldPlan.length;

    const newPlan: MonthlyCapacity[] = [];

    if (mode === CapacityPeriodResizeMode.DEFAULT) {
      for (let i = 0; i < newLength; i++) {
        const source = i < oldLength ? oldPlan[i] : oldPlan[oldLength - 1]; // extend using last known value

        newPlan.push({
          month: offsetMonthsToYYYYMM(start, i),
          capacity: source.capacity,
          adjustment: source.adjustment,
        });
      }
    }

    if (mode === CapacityPeriodResizeMode.DISTRIBUTE) {
      const total = this.totalCapacity;
      const base = Math.floor(total / newLength);
      let remainder = total % newLength;

      for (let i = 0; i < newLength; i++) {
        const extra = remainder > 0 ? 1 : 0;
        remainder--;

        newPlan.push({
          month: offsetMonthsToYYYYMM(start, i),
          capacity: base + extra,
        });
      }
    }

    this.metadata.supplyPlan = newPlan;
    this.updateTimestamp();
    this.markFinanceDirty();

    return this;
  }

  /**
   * Replaces the entire supply plan.
   * @param supplyPlan - Array of { month: YYYYMM, units: number, adjustment?: number }.
   * @returns {this} Updated product instance.
   */
  setCapacity(supplyPlan: MonthlyCapacity[]): this {
    if (!Array.isArray(supplyPlan))
      throw new Error("Supply plan must be an array");
    supplyPlan.forEach((s) => {
      if (!isValidYYYYMM(s.month)) throw new Error(`Invalid month: ${s.month}`);
      if (typeof s.capacity !== "number")
        throw new Error("Capacity must be a number");
    });
    this.metadata.supplyPlan = [...supplyPlan];
    this.updateTimestamp();
    this.markFinanceDirty();
    return this;
  }

  /**
   * Adds a new monthly supply entry.
   * @param month - Month in YYYY-MM format.
   * @param capacity - Units planned.
   * @param adjustment - Optional adjustment.
   * @returns {this} Updated product instance.
   * @throws Error if month already exists or invalid.
   */
  addCapacity(month: YYYYMM, capacity: number, adjustment?: number): this {
    if (!isValidYYYYMM(month)) throw new Error("Invalid month");
    this.metadata.supplyPlan ??= [];
    if (this.metadata.supplyPlan.some((s) => s.month === month)) {
      throw new Error(
        `Month ${month} already exists. Use updateCapacityUnits or updateCapacityAdjustment`
      );
    }
    this.metadata.supplyPlan.push({ month, capacity, adjustment });
    this.updateTimestamp();
    this.markFinanceDirty();
    return this;
  }

  /**
   * Updates units for an existing month.
   * @param month - Month in YYYY-MM format.
   * @param units - New number of units.
   * @returns {this} Updated product instance.
   * @throws Error if month not found or invalid.
   */
  updateCapacityUnits(month: YYYYMM, units: number): this {
    if (!isValidYYYYMM(month)) throw new Error("Invalid month");
    const plan = this.metadata.supplyPlan?.find((s) => s.month === month);
    if (!plan) throw new Error(`Month ${month} not found`);
    if (typeof units !== "number") throw new Error("Units must be a number");
    plan.capacity = units;
    this.updateTimestamp();
    this.markFinanceDirty();
    return this;
  }

  /**
   * Updates adjustment for an existing month.
   * @param month - Month in YYYY-MM format.
   * @param adjustment - New adjustment value (or undefined to reset).
   * @returns {this} Updated product instance.
   * @throws Error if month not found or invalid.
   */
  updateCapacityAdjustment(month: YYYYMM, adjustment?: number): this {
    if (!isValidYYYYMM(month)) throw new Error("Invalid month");
    const plan = this.metadata.supplyPlan?.find((s) => s.month === month);
    if (!plan) throw new Error(`Month ${month} not found`);
    plan.adjustment = adjustment;
    this.updateTimestamp();
    this.markFinanceDirty();
    return this;
  }

  /**
   * Removes a month from the supply plan.
   * @param month - Month in YYYY-MM format.
   * @returns {this} Updated product instance.
   */
  removeCapacity(month: YYYYMM): this {
    if (!isValidYYYYMM(month)) throw new Error("Invalid month");
    const index = this.metadata.supplyPlan?.findIndex((s) => s.month === month);
    if (index === undefined || index === -1)
      throw new Error(`Month ${month} not found`);
    this.metadata.supplyPlan!.splice(index, 1);
    this.updateTimestamp();
    this.markFinanceDirty();
    return this;
  }

  /**
   * Clears the entire supply plan.
   * @returns {this} Updated product instance.
   */
  clearCapacity(): this {
    this.metadata.supplyPlan = [];
    this.updateTimestamp();
    this.markFinanceDirty();
    return this;
  }

  /* ------------------ AGGREGATE FINANCE GETTERS ------------------ */

  get averageMonthlyRevenue(): MajikMoney {
    const months = this.metadata.supplyPlan?.length ?? 0;
    if (months === 0) return this.DEFAULT_ZERO();
    return this.grossRevenue.divide(months);
  }

  get averageMonthlyProfit(): MajikMoney {
    const months = this.metadata.supplyPlan?.length ?? 0;
    if (months === 0) return this.DEFAULT_ZERO();
    return this.grossProfit.divide(months);
  }

  /**
   * Calculates total revenue across all months.
   * @returns {MajikMoney} Total revenue.
   */
  get grossRevenue(): MajikMoney {
    this.recomputeFinance();
    return this.metadata.finance.revenue.gross.value;
  }

  /**
   * Calculates total COGS across all months.
   * @returns {MajikMoney} Total COGS.
   */
  get grossCost(): MajikMoney {
    this.recomputeFinance();
    return this.metadata.finance.cogs.gross.value;
  }

  /**
   * Calculates total gross profit across all months.
   * @returns {MajikMoney} Gross profit.
   */
  get grossProfit(): MajikMoney {
    this.recomputeFinance();
    return this.metadata.finance.profit.gross.value;
  }

  get netRevenue(): MajikMoney {
    this.recomputeFinance();
    return this.metadata.finance.revenue.net.value;
  }

  get netProfit(): MajikMoney {
    this.recomputeFinance();
    return this.metadata.finance.profit.net.value;
  }

  /* ------------------ FINANCE HELPERS ------------------ */

  private computeGrossRevenue(): MajikMoney {
    const supply = this.metadata.supplyPlan ?? [];
    return supply.reduce(
      (acc, s) => acc.add(this.srp.multiply(s.capacity + (s.adjustment ?? 0))),
      this.DEFAULT_ZERO()
    );
  }

  private computeGrossCOGS(): MajikMoney {
    const supply = this.metadata.supplyPlan ?? [];
    const unitCOGS = this.metadata.cogs.reduce(
      (acc, c) => acc.add(c.subtotal),
      this.DEFAULT_ZERO()
    );

    return supply.reduce(
      (acc, s) => acc.add(unitCOGS.multiply(s.capacity + (s.adjustment ?? 0))),
      this.DEFAULT_ZERO()
    );
  }

  private computeGrossProfit(): MajikMoney {
    return this.computeGrossRevenue().subtract(this.computeGrossCOGS());
  }

  private recomputeFinance(): void {
    if (!this.financeDirty) return;

    const grossRevenue = this.computeGrossRevenue();
    const grossCOGS = this.computeGrossCOGS();
    const grossProfit = this.computeGrossProfit();
    const grossIncome = grossProfit;

    const revenueMargin = grossRevenue.isZero()
      ? 0
      : grossProfit.ratio(grossRevenue);
    const cogsMargin = grossRevenue.isZero()
      ? 0
      : grossCOGS.ratio(grossRevenue);

    this.metadata.finance = {
      revenue: {
        gross: { value: grossRevenue, marginRatio: 1 }, // 100% of revenue
        net: { value: grossRevenue, marginRatio: 1 }, // placeholder for discounts/returns
      },
      cogs: {
        gross: { value: grossCOGS, marginRatio: cogsMargin },
        net: { value: grossCOGS, marginRatio: cogsMargin },
      },
      income: {
        gross: { value: grossIncome, marginRatio: revenueMargin },
        net: { value: grossIncome, marginRatio: revenueMargin },
      },
      profit: {
        gross: { value: grossProfit, marginRatio: revenueMargin },
        net: { value: grossProfit, marginRatio: revenueMargin },
      },
    };

    this.financeDirty = false;
  }

  /**
   * Calculates revenue for a given month.
   * @param month - YYYYMM month.
   * @returns {MajikMoney} Revenue for the month.
   */
  getRevenue(month: YYYYMM): MajikMoney {
    if (!isValidYYYYMM(month)) throw new Error("Invalid month");
    if (!this.metadata.supplyPlan) return this.DEFAULT_ZERO();

    const plan = this.metadata.supplyPlan.find((s) => s.month === month);

    if (!plan) return this.DEFAULT_ZERO();

    return this.srp.multiply(plan.capacity + (plan.adjustment ?? 0));
  }

  get cogs(): readonly COGSItem[] {
    return this.metadata.cogs;
  }

  /**
   * Calculates COGS for a given month.
   * @param month - YYYYMM month.
   * @returns {MajikMoney} COGS for the month.
   */
  getCOGS(month: YYYYMM): MajikMoney {
    if (!isValidYYYYMM(month)) throw new Error("Invalid month");
    if (!this.metadata.supplyPlan) return this.DEFAULT_ZERO();
    const plan = this.metadata.supplyPlan.find((s) => s.month === month);

    if (!plan) return this.DEFAULT_ZERO();

    const perUnitCOGS = this.metadata.cogs.reduce(
      (acc, c) => acc.add(c.subtotal),
      this.DEFAULT_ZERO()
    );

    return perUnitCOGS.multiply(plan.capacity + (plan.adjustment ?? 0));
  }

  /**
   * Alias for Get COGS. Retrieves COGS for a given month.
   * @param month - YYYYMM month.
   * @returns {MajikMoney} COGS for the month.
   */
  getCost(month: YYYYMM): MajikMoney {
    return this.getCOGS(month);
  }

  /**
   * Calculates profit for a given month.
   * @param month - YYYYMM month.
   * @returns {MajikMoney} Profit for the month.
   */
  getProfit(month: YYYYMM): MajikMoney {
    if (!isValidYYYYMM(month)) throw new Error("Invalid month");
    return this.getRevenue(month).subtract(this.getCOGS(month));
  }

  /**
   * Calculates margin for a given month.
   * @param month - YYYYMM month.
   * @returns {number} Profit margin as a decimal (0â€“1).
   */
  getMargin(month: YYYYMM): number {
    if (!isValidYYYYMM(month)) throw new Error("Invalid month");
    const revenue = this.getRevenue(month);
    return revenue.isZero()
      ? 0
      : this.getProfit(month)
          .divideDecimal(revenue.toMajorDecimal())
          .toNumber();
  }

  /**
   * Calculates Net Revenue for a given month.
   * @param month - YYYYMM
   * @param discounts - Total discounts for the month (optional)
   * @param returns - Total returns for the month (optional)
   * @param allowances - Total allowances for the month (optional)
   * @returns {MajikMoney} Net Revenue
   */
  getNetRevenue(
    month: YYYYMM,
    discounts?: MajikMoney,
    returns?: MajikMoney,
    allowances?: MajikMoney
  ): MajikMoney {
    if (!isValidYYYYMM(month)) throw new Error("Invalid month");
    let net = this.getRevenue(month);
    if (discounts) net = net.subtract(discounts);
    if (returns) net = net.subtract(returns);
    if (allowances) net = net.subtract(allowances);
    return net;
  }

  /**
   * Calculates Net Profit for a given month.
   * @param month - YYYYMM
   * @param operatingExpenses - Total operating expenses (optional)
   * @param taxes - Total taxes (optional)
   * @param discounts - Total discounts for the month (optional)
   * @param returns - Total returns for the month (optional)
   * @param allowances - Total allowances for the month (optional)
   * @returns {MajikMoney} Net Profit
   */
  getNetProfit(
    month: YYYYMM,
    operatingExpenses?: MajikMoney,
    taxes?: MajikMoney,
    discounts?: MajikMoney,
    returns?: MajikMoney,
    allowances?: MajikMoney
  ): MajikMoney {
    if (!isValidYYYYMM(month)) throw new Error("Invalid month");
    let netRev = this.getNetRevenue(month, discounts, returns, allowances);
    if (operatingExpenses) netRev = netRev.subtract(operatingExpenses);
    if (taxes) netRev = netRev.subtract(taxes);
    return netRev;
  }

  /**
   * Alias for getNetProfit, same as Net Income
   */
  getNetIncome(
    month: YYYYMM,
    operatingExpenses?: MajikMoney,
    taxes?: MajikMoney,
    discounts?: MajikMoney,
    returns?: MajikMoney,
    allowances?: MajikMoney
  ): MajikMoney {
    if (!isValidYYYYMM(month)) throw new Error("Invalid month");
    return this.getNetProfit(
      month,
      operatingExpenses,
      taxes,
      discounts,
      returns,
      allowances
    );
  }

  /* ------------------ INVENTORY ------------------ */

  get isOutOfStock(): boolean {
    return (
      this.metadata.inventory.stock !== null &&
      this.metadata.inventory.stock <= 0
    );
  }

  reduceStock(units: number): this {
    if (this.metadata.inventory.stock === null) return this;
    if (!Number.isInteger(units) || units <= 0) {
      throw new Error("Units must be a positive integer");
    }

    this.metadata.inventory.stock = Math.max(
      0,
      this.metadata.inventory.stock - units
    );
    this.updateTimestamp();
    return this;
  }

  get unitCost(): MajikMoney {
    return this.metadata.cogs.reduce(
      (acc, c) => acc.add(c.subtotal),
      this.DEFAULT_ZERO()
    );
  }

  get unitProfit(): MajikMoney {
    return this.srp.subtract(this.unitCost);
  }

  get unitMargin(): number {
    return this.srp.isZero() ? 0 : this.unitProfit.ratio(this.srp);
  }

  get price(): MajikMoney {
    return this.srp.isZero() ? this.DEFAULT_ZERO() : this.srp;
  }

  getMonthlySnapshot(month: YYYYMM) {
    return {
      month,
      revenue: this.getRevenue(month),
      cogs: this.getCOGS(month),
      profit: this.getProfit(month),
      margin: this.getMargin(month),
      netRevenue: this.getNetRevenue(month),
      netIncome: this.getNetIncome(month),
    };
  }

  /* ------------------ UTIL ------------------ */

  /**
   * Validates the `MajikProduct` instance to ensure that all required fields are set.
   * If any required field is missing or invalid, the method will either throw an error
   * or return `false`, depending on the `throwError` parameter.
   *
   * @param throwError - Optional. If true, throws an error for the first missing or invalid property.
   *                     Defaults to false, in which case it returns a boolean indicating validity.
   * @returns {boolean} - Returns true if the instance is valid, or false if not when `throwError` is false.
   * @throws {Error} - Throws an error when a required field is missing or invalid, and `throwError` is true.
   */
  validateSelf(throwError: boolean = false): boolean {
    const requiredFields = [
      { field: this.id, name: "ID" },
      { field: this.timestamp, name: "Timestamp" },

      // Personal Information
      { field: this.name, name: "Product Name" },
      { field: this.metadata.description.text, name: "Description" },
      { field: this.metadata.srp.toMajor(), name: "SRP" },
    ];

    for (const { field, name } of requiredFields) {
      if (field === null || field === undefined || field === "") {
        if (throwError) {
          throw new Error(
            `Validation failed: Missing or invalid property - ${name}`
          );
        }
        return false;
      }
    }

    return true;
  }

  /**
   * Converts the current `MajikProduct` class to a plain JSON object and automatically generates an ID.
   * @returns {object} - A plain JSON object representation of the Product with an autogenerated ID.
   */
  finalize(): object {
    return {
      ...this.toJSON(),
      id: autogenerateID("mjkp"),
    };
  }

  /**
   * Converts the current MajikProduct object to a plain JavaScript object (JSON).
   * @returns {object} - The plain object representation of the MajikProduct instance.
   */
  toJSON(): object {
    const preJSON = {
      __type: "MajikProduct",
      __object: "json",
      id: this.id,
      slug: this.slug,
      name: this.name,
      category: this.category,
      srp: this.srp,
      status: this.status,
      type: this.type,
      timestamp: this.timestamp,
      last_update: this.last_update,
      metadata: this.metadata,
      settings: this.settings,
    };

    const serializedMoney: object = serializeMoney(preJSON);

    return serializedMoney;
  }

  /**
   * Static method to parse a JSON string or object into a `MajikProduct` instance.
   *
   * @param json - A JSON string or plain object to be parsed.
   * @returns {MajikProduct} - A new MajikProduct instance based on the parsed JSON.
   * @throws Will throw an error if required properties are missing.
   */

  static parseFromJSON(json: string | object): MajikProduct {
    // If the input is a string, parse it as JSON
    const rawParse: MajikProduct =
      typeof json === "string"
        ? JSON.parse(json)
        : structuredClone
        ? structuredClone(json)
        : JSON.parse(JSON.stringify(json));

    console.log("Parsing Data: ", rawParse);

    const parsedData: MajikProduct = deserializeMoney(rawParse);

    // Validate required properties
    if (!parsedData.id) {
      throw new Error("Missing required property: 'id'");
    }

    if (!parsedData.timestamp) {
      throw new Error("Missing required property: 'timestamp'");
    }

    if (!parsedData.metadata) {
      throw new Error("Missing required property: 'Metadata'");
    }

    if (!parsedData.settings) {
      throw new Error("Missing required property: 'Settings'");
    }

    return new MajikProduct(
      parsedData.id,
      parsedData?.slug,
      parsedData.name,
      parsedData.metadata,
      parsedData.settings,
      parsedData?.timestamp,
      parsedData?.last_update
    );
  }

  /**
   * Updates the `last_update` timestamp to the current time.
   * This method should be called internally whenever a property is modified.
   */
  private updateTimestamp(): void {
    this.last_update = new Date().toISOString();
  }

  private assertCurrency(money: MajikMoney): void {
    if (money.currency.code !== this.srp.currency.code) {
      throw new Error("Currency mismatch with product SRP");
    }
  }
}

export function isMajikProductClass(item: MajikProduct): boolean {
  return item.__object === "class";
}

export function isMajikProductJSON(item: MajikProduct): boolean {
  return item.__object === "json";
}
